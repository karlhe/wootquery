#summary Analysis of jQuery.
#labels Phase-Requirements,Phase-Design
----
=Part 2: Study a language that solves a similar problem and describe it in this homework.=

Since we are just writing a simpler version of jQuery, there is no better language to analyze than jQuery itself.

==1. Code Example:==

{{{
<html>
    <head>
        <title>qqScript</title>
        <style type="text/css">
            .under { text-decoration: underline }
        </style>
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript">
            $(document).ready(function(){
                $("p > span").hover(function() {
                    $(this).addClass("under");
                },function() {
                    $(this).removeClass("under");
                });
            });
        </script>
    </head>
    <body>
        <a href="http://jquery.com/">jQuery</a>
        <p>This was a <span>triumph</span>.</p>
    </body>
</html>
}}}

This is a simple jQuery example that demonstrates multiple abilities. Analyzing the code:

{{{
$(document).ready(...);
}}}

This jQuery code targets the document DOM-node, and executes the method ready. Ready according to documentation basically means "execute the body when it is done loading, but don't wait for images", as opposed to window.onLoad as normally used in Javascript, which waits for everything to finish loading.

{{{
$("p > span").hover(onstate,offstate);
}}}

The target for this is some kind of selector, which will target any span tag that is a child of a paragraph tag. The hover method takes two arguments, a function to execute for the hover on state, and a function to execute when the mouse leaves the on state. In the above example, it will apply a CSS class that underlines the span when it is hovered.

==2. Implementation:==

{{{
(function(){

var 
	// Will speed up references to window, and allows munging its name.
	window = this,
	// Will speed up references to undefined, and allows munging its name.
	undefined,
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,
	// Map over the $ in case of overwrite
	_$ = window.$,

	jQuery = window.jQuery = window.$ = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context );
	},

	...
;

jQuery.fn = jQuery.prototype = {
	init: function( selector, context ) {
            ...
        },
        ...
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;
}}}

Although jQuery is more complex, the above code describes the main idea behind how jQuery is implemented that we carried over to wootQuery. In pseudocode:

{{{
execute the following block:
   define the variables window.$ and window.jQuery to reference the jQuery function
   take in the arguments selector and context, and pass them to jQuery.prototype.init
   define jQuery.prototype
   set the prototype of jQuery.prototype.init to jQuery.prototype
}}}

Other functions are defined in the same way as init. jQuery doesn't quite use only the Javascript prototype model, and instead creates some type of recursive definition based on the init method of the prototype. We decided to stick solely to the prototype model because it is much simpler to understand, though it may be less elegant. We can think of adding functions as adding methods to the object class, so this simple concept makes the job easier for programmers, especially for those who want to extend the code to add more functionality. We are not entirely sure about the trade-offs between our implementation and jQuery's implementation because we did not have much time to fully understand jQuery's code; jQuery's complexity may be a drawback for programmers who want to modify jQuery but don't know about jQuery's implementation, as they would have to study the code a lot just to understand it and to add extensions to it. Instead, we implemented it in a more straightforward manner to make it easier for programmers. Due to time constraints, we mostly aimed for adding functionality; the next step, if we had more time, would be to optimize the code. We are still able to achieve the same expressive power as jQuery since we are using the same syntax on the user end. 

{{{
$(this).method(args);
}}}
When something like this is called, the `jQuery` function above is called, and a `new jQuery.fn.init( selector, context )` is returned. In other words, call-chaining is accomplished by passing around the return value of prototype.init.

Because lots of what jQuery does is the same as what wootQuery does, we won't elaborate too much here, for more details see [Implementation].

We tried thinking of alternative implementations to see if we could optimize the performance. Currently we traverse the whole DOM for elements, store them in a list, and run through the list every time we call a method on them. This could be slow if the page is huge and we have a lot of matched elements. We thought about evaluating and applying methods eagerly, where we would search through DOM, and right when it finds a target element it would apply all the chained methods to it and then find the next element. This would work in some cases and would be more efficient if the set of matched elements is huge and the page is large. However, it can lead to unpredicted behavior if some of the matched elements depend on other matched elements in their chained method calls, causing chained calls to not work as well in some cases. It is also harder to implement and less intuitive, since we aren't applying a method uniformly to all matched elements, and then applying the next method, and so on. We decided to stick with the simple prototype model, in which we can apply object-oriented programming concepts.  