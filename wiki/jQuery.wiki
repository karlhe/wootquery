#summary Analysis of jQuery.
#labels Phase-Requirements,Phase-Design
----
=Part 2: Study a language that solves a similar problem and describe it in this homework.=

Since we are just writing a simpler version of jQuery, there is no better language to analyze than jQuery itself.

==1. Code Example:==

{{{
<html>
    <head>
        <title>qqScript</title>
        <style type="text/css">
            .under { text-decoration: underline }
        </style>
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript">
            $(document).ready(function(){
                $("p > span").hover(function() {
                    $(this).addClass("under");
                },function() {
                    $(this).removeClass("under");
                });
            });
        </script>
    </head>
    <body>
        <a href="http://jquery.com/">jQuery</a>
        <p>This was a <span>triumph</span>.</p>
    </body>
</html>
}}}

This is a simple jQuery example that demonstrates multiple abilities. Analyzing the code:

{{{
$(document).ready(...);
}}}

This jQuery code targets the document DOM-node, and executes the method ready. Ready according to documentation basically means "execute the body when it is done loading, but don't wait for images", as opposed to window.onLoad as normally used in Javascript, which waits for everything to finish loading.

{{{
$("p > span").hover(onstate,offstate);
}}}

The target for this is some kind of selector, which will target any span tag that is a child of a paragraph tag. The hover method takes two arguments, a function to execute for the hover on state, and a function to execute when the mouse leaves the on state. In the above example, it will apply a CSS class that underlines the span when it is hovered.

==2. Implementation:==

{{{
(function(){

var 
	// Will speed up references to window, and allows munging its name.
	window = this,
	// Will speed up references to undefined, and allows munging its name.
	undefined,
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,
	// Map over the $ in case of overwrite
	_$ = window.$,

	jQuery = window.jQuery = window.$ = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context );
	},

	...
;

jQuery.fn = jQuery.prototype = {
	init: function( selector, context ) {
            ...
        },
        ...
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;
}}}

Although jQuery is more complex, the above code describes the main idea behind how jQuery is implemented that we carried over to wootQuery. In pseudocode:

{{{
execute the following block:
   define the variables window.$ and window.jQuery to reference the jQuery function
   take in the arguments selector and context, and pass them to jQuery.prototype.init
   define jQuery.prototype
   set the prototype of jQuery.prototype.init to jQuery.prototype
}}}

Other functions are defined in the same way as init. jQuery doesn't quite use only the Javascript prototype model, and instead creates some type of recursive definition based on the init method of the prototype. We decided to stick solely to the prototype model because it is much simpler to understand, though it may be less elegant. We can think of adding functions as adding methods to the object class, so this simple concept makes the job easier for programmers, especially for those who want to extend the code to add more functionality. We are not entirely sure about the trade-offs between our implementation and jQuery's implementation because we did not have much time to try to fully understand jQuery's code; jQuery's complexity may be a drawback for programmers who don't know about jQuery's implementation, as they would have to study the code a lot just to understand it and to add extensions. Instead, we implemented it in a more straightforward manner. Due to time constraints, we mostly aimed for adding functionality, so we assume our code may be less elegant and less optimal than jQuery's; the next step, if we had more time, would be to optimize the code. We are still able to achieve the same expressive power as jQuery since we are using the same syntax on the user end. 

{{{
$(this).method(args);
}}}
When something like this is called, the `jQuery` function above is called, and a `new jQuery.fn.init( selector, context )` is returned. In other words, call-chaining is accomplished by passing around the return value of prototype.init.

Because lots of what jQuery does is the same as what wootQuery does, we won't elaborate too much here, for more details see [Implementation].