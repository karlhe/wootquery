#summary Some thought behind how to implement the language.
#labels Phase-Design
----
= Part 4: Implementation Decisions =

Javascript is the only really universally-supported language for client-side scripting. It is unreasonable to try to make our language work as a stand-alone scripting language. In that case, there are only two potential options:

   1. Make our language work as a library on top on Javascript.
   2. Make our language "compile" into Javascript, as in everything will be converted into pure Javascript as opposed to needing a library to support the syntax.

We have decided to write our language wootQuery as a Javascript library. Because most of the syntax and underlying representation will be the same, I will describe this in terms of wootQuery and note where it departs from jQuery.

== Frontend: ==
wootQuery's internal representation is a wootQuery object. Take as an example this code fragment:
{{{
$('h1').addClass('bold');
}}}
This will pass the string `h1` into the `$()` function. The `window.$()` function actually just references the wootQuery function in our library. The function processes this input and retrieves all matching elements--in this case, all `<h1>` tags--and stores them in the `wootQuery.elements` variable. This wootQuery object is then returned, which allows `addClass()` to be passed to it. `addClass()` is simply a function stored in the wootQuery prototype. Using this call-chaining method, everything that can be call-chained returns a wootQuery object with the new state.

== The Core Language: ==
The core language will be Javascript. All features will be some kind of sugar on top of Javascript. For example, `$('a').addClass('b');` would break down to something like this:

{{{
for(element in document.getElementsByTagName('a')) {
  element.setAttribute('class','b');
}
}}}

In actuality, that Javascript code does not comprise the entirety of what wootQuery does. For one, `getElementsByTagName()` does not return an `Array` but a `NodeList`, which is more limited in terms of available methods. In addition, what we want to do is not to replace the class, but to add one (but only if it isn't already applied). wootQuery takes care of both of these things.

Desugaring these features is actually relatively simple. All arguments to `$()` are expected to be selectors, so the proper element-fetching processes are executed. For everything else, there is simply a function in `wootQuery.prototype` that will run the appropriate Javascript.

It is worth noting that Javascript does not run consistently on all browsers. Because of the environment in which we developed (Firefox and Chrome), we did not fully account for the ability to perform in other browsers (such as Internet Explorer) when developing wootQuery. jQuery, on the other hand, has elegant code that takes care of cross-browser compatibility issues.

== Internal Representation: ==
The internal representation is largely defined in wootQuery.prototype. Objects in Javascript are essentially hash-maps, there are keys corresponding to each wootQuery function that return a Javascript function that performs the desired operation. For example, this is the addClass method:
{{{
    var wootQuery = window.$ = window.wootQuery = function(selector,context) {
        // Return a new wootQuery object
        return new wootQuery.fn.init(selector);
    }
    ...
    wootQuery.fn = wootQuery.prototype = {
        ...
        addClass: function(classNames) {
            this.elements.map(function(element) {
                var getClass = element.getAttribute("class");
                if (getClass == "" || getClass == null) {
                    element.setAttribute("class", classNames);
                } else {
                    element.setAttribute("class", getClass + ' ' + classNames);
                }
            });
            return this;
        },
        ...
    }
    wootQuery.fn.init.prototype = wootQuery.fn;
}}}

We've included some additional code in the above example to discuss a further point. This is a little trick that we carried over after having studied the jQuery implementation a bit. When call-chaining in wootQuery, what is being passed around isn't actually a wootQuery object, it is the init method of the wootQuery prototype (though it can still be thought of as an object). The init method is fairly standard for Javascript prototypes, however the wootQuery version returns `this`, which allows it to be passed around in place of the object itself. This way works flawlessly and we can't say the same about the original approach we attempted.

As displayed in `addClass()` above, except for special cases, each method returns the object after the operation is completed, to allow addition call-chaining.

The matched DOM elements themselves are simply passed around in the `elements` variable, in a form such as this:
{{{
[ [HTMLUListElement], [HTMLListElement], ... ]
}}}
With this implementation we can use Javascript's `map` function to perform the necessary tasks on each of the matched DOM elements, as shown above in the example code.

== Interpreter/Compiler: ==
wootQuery code is a chained function-call in Javascript. In the initial creation of the wootQuery object to be passed around, the wootQuery.prototype.init function is called. Init takes the argument to `$()` and searches the DOM for corresponding elements. The elements referenced in the object comprises the entire "state" of the object. Once the initial state is established, all further methods simply modify the state or return information based on the state, as shown in the example code above.

== Debugging: ==
Debugging in Javascript is inherently tricky, however all the major browsers include a Javascript console which shows flaws in Javascript code. The behavior of the wootQuery functions, however, can't be tested in this manner. While there are tools available to perform behavior-driven tests, we do not have the time-luxury to be learning these tools, so our tests have been done manually by writing test code and testing each method. Example test code is available in `index.html` of the root folder of the repository, and also in the demo examples. Each method is fairly independent of one another, so we would write a method, write test cases, test it, and then move on to the next method. 